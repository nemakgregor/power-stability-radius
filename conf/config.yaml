# Hydra-style config for power-stability-radius.
# This file is the single source of defaults for the unified CLI.
#
# CLI flags override values from this file.

run_tests: true

logging:
  runs_dir: runs
  level_console: INFO
  level_file: DEBUG

  # timestamp  -> runs/<timestamp>/
  # overwrite  -> runs/<run_name>/  (folder is deleted/recreated each run)
  run_dir_mode: timestamp
  run_name: latest

opf:
  # Project policy: must be "highs"
  solver_name: highs
  threads: 14
  random_seed: 42

  # Headroom factor for OPF line constraints (security margin).
  # Example: 0.95 means OPF is solved with 95% of the thermal limits,
  #          while radii are computed w.r.t. the original limits.
  headroom_factor: 0.99

  # NOTE:
  # PyPSA requires finite thermal limits. We use this value as a deterministic surrogate
  # for "unconstrained" lines (rateA==0 / +inf / NaN).
  #
  # Keep it large enough to never bind in realistic cases, but NOT astronomically large:
  # values like 1e9 can trigger HiGHS scaling warnings and lead to measurable numerical
  # drift (e.g., OPF->DCOperator flow mismatches at MW level).
  unconstrained_line_nom_mw: 1.0e5

dc:
  mode: operator
  chunk_size: 256
  dtype: float64

tolerances:
  opf_dc_flow_consistency_tol_mw: 1
  opf_bus_balance_tol_mw: 1

table:
  # Default table columns used by `compute` when `--table-columns` is empty.
  default_columns:
    - flow0_mw
    - p0_mw
    - p_limit_mw_est
    - margin_mw
    - norm_g
    - metric_denom
    - sigma_flow
    - radius_l2
    - radius_metric
    - radius_sigma
    - overload_probability
    - radius_nminus1
    - worst_contingency
    - worst_contingency_line_idx

compute:
  input: data/input/pglib_opf_case30_ieee.m
  slack_bus: 0

  dc_mode: ${dc.mode}
  dc_chunk_size: ${dc.chunk_size}
  dc_dtype: ${dc.dtype}

  inj_std_mw: 1.0

  compute_nminus1: 0
  nminus1_update_sensitivities: 1
  nminus1_islanding: skip

  export_results: ""
  save_csv: 1
  max_rows: null

  # comma-separated, empty -> table.default_columns
  table_columns: ""

report:
  results_dir: verification/results
  out: verification/report.md

  # Monte Carlo verification parameters
  n_samples: 50000
  seed: 42
  chunk_size: 256
  feas_tol_mw: 0.0
  cert_tol_mw: 1
  cert_max_samples: 5000

  generate_missing_results: 1

  # Parameters used when auto-generating missing results.json
  compute:
    dc_mode: ${compute.dc_mode}
    slack_bus: ${compute.slack_bus}
    compute_nminus1: ${compute.compute_nminus1}

    dc_chunk_size: ${compute.dc_chunk_size}
    dc_dtype: ${compute.dc_dtype}

    inj_std_mw: ${compute.inj_std_mw}

    nminus1_update_sensitivities: ${compute.nminus1_update_sensitivities}
    nminus1_islanding: ${compute.nminus1_islanding}

  # Case list for the report (no hard-coded cases in code).
  # `results` is interpreted relative to `report.results_dir` unless absolute.
  cases:
    - id: case30
      input: data/input/pglib_opf_case30_ieee.m
      results: case30.json
      known_critical_pairs:
        - [1, 2]
        - [2, 4]
        - [4, 6]

    - id: case118
      input: data/input/pglib_opf_case118_ieee.m
      results: case118.json
      known_critical_pairs:
        - [38, 65]
        - [30, 38]

    - id: case300
      input: data/input/pglib_opf_case300_ieee.m
      results: case300.json

    - id: case1354_pegase
      input: data/input/pglib_opf_case1354_pegase.m
      results: case1354_pegase.json